export const data: string =
  '--[[\n\nfs.writeFileSync("lockNextWorkflowApplication-4.ts", `export const data = JSON.parse(${JSON.stringify(fs.readFileSync("lockNextWorkflowApplication-4.lua").toString("utf-8"))});`)\n\nПолучить есклюзивную блокировку над иденификатором `<WF_APP_UUID>` приложения `Workflow App`.\nДля этого LUA процедура делат следующее:\n\t* Выбрать список активных `Workflow App` `workflow:processing:<RUNNER_VERSION>`\n\t* Перебирая полученный список (!!!с головы!!!):\n\t\t* Если `<WF_APP_UUID>` выполняется в текущий момент `workflow:lock:<WF_APP_UUID>`, переходим к следующему элементу списка (continue;)\n\t\t* Если `<WF_APP_UUID>` находятся в брекоинте `workflow:breakpoint:wait:<WF_APP_UUID>`, переходим к следующему элементу списка (continue;)\n\t\t* Блокируем запись, в `workflow:lock:<WF_APP_UUID>`\n\t\t* Перемещаем запись `<WF_APP_UUID>` в конец(хвост) списка `workflow:processing:<RUNNER_VERSION>` путем увеличения значения Score (обеспечиваем цикличность)\n\t\t* Возвращаем пользователю заблокированный `<WF_APP_UUID>`\n\t* Возвращаем пользователю null\n\n== Версионирование ==\nФормат RUNNER_VERSION: MAJOR.MINOR (см https://semver.org/)\nВерсионирование построено на принципе проверки, что раннер может обрабатывать активити версий\nниже-равно чем MAJOR.MINOR.\nДругими словами, если в системе появляются более новые версии, они будут обработаны\nтолько на более новый раннерах\n\n\n* SET  `workflow:tick:<WF_APP_UUID>` `{ ..., "workflowVirtualMachineSnapshot": { ...json... }, nextTickTags: ["tag1","tag2", ...],  ... }` - Результат последнего тика (копия самой свежей записи из Postgress `workflow_tick`)\n* ZADD `workflow:processing:<RUNNER_VERSION>` `<WF_APP_UUID>` - хранит сортированный спиcок незавершенных `Workflow App` (копия из Postgress `FROM workflow_tick WHERE crash_report IS NULL AND state_snapshot IS NOT NULL`). Score записи обновляется при блокировании (функция `lockNextWorkflowApplication-4.lua`), что обеспечивает перемещение залоченой записи в хвост списка (перемешивание).\n* SET  `workflow:lock:<WF_APP_UUID>` `<WORKFLOW_WORKER_ID>` - хранит строку указывающую на имя-идентификатор сервиса который владеет(залочил) `Workflow App` в текущий момент времени\n* SET  `workflow:breakpoint:wait:<WF_APP_UUID>` `<BREAKPOINT_NAME>` - хранит имя брекпоинта в котором сейчас спит `Workflow App`\n\n]]\nlocal runnerVersion = KEYS[1]\nlocal lockInstance = KEYS[2]\nlocal lockTimeout = KEYS[3]\nlocal workerTagsJsonArray = KEYS[4]\n\nlocal workerTags = cjson.decode(workerTagsJsonArray)\n\nlocal processingKey = "workflow:processing:" .. runnerVersion\n\nredis.replicate_commands()\n\nlocal now = redis.call("TIME")\nlocal jstimestamp = now[1] .. string.sub(now[2], 0, 3)\nlocal activesWorkflowApplications = redis.call("ZRANGE", processingKey, 0, -1)\nif activesWorkflowApplications == nil then\n    return nil\nend\n\nfor k, processingWorkflowApplicationUuid in pairs(activesWorkflowApplications) do\n    local lockKey = "workflow:lock:" .. processingWorkflowApplicationUuid\n    -- check: is not lock-ed\n    if not redis.call("GET", lockKey) then\n        local breakpointKey = "workflow:breakpoint:wait:" .. processingWorkflowApplicationUuid\n        -- check: is not breakpoint-ed\n        if not redis.call("GET", breakpointKey) then\n            local lastTickKey = "workflow:tick:" .. processingWorkflowApplicationUuid\n            local lastTickJsonData = redis.call("GET", lastTickKey)\n            if not lastTickJsonData then\n                -- no last tick data related to processingWorkflowApplicationUuid, so remove this from processing at all\n                -- this will restored from Posgtress with tick data\n                redis.call("ZREM", processingKey, processingWorkflowApplicationUuid)\n            else\n                -- do lock\n                local lastTickData = cjson.decode(lastTickJsonData)\n                -- check: next tick tags\n                local allowLockByThisInstance = true\n                if lastTickData.nextTickTags then\n                    for tagIndex = 1, #lastTickData.nextTickTags do\n                        local requiredTag = lastTickData.nextTickTags[tagIndex]\n                        local isRequiredTagPresentedInWorkerTags = false\n                        for _, workerTag in pairs(workerTags) do\n                            if workerTag == requiredTag then\n                                isRequiredTagPresentedInWorkerTags = true\n                                break\n                            end\n                        end\n                        if not isRequiredTagPresentedInWorkerTags then\n                            allowLockByThisInstance = false\n                            break\n                        end\n                    end\n                end\n                -- is tags allows execution\n                if allowLockByThisInstance then\n                    -- update scope (move to tail)\n                    redis.call("ZADD", processingKey, jstimestamp, processingWorkflowApplicationUuid)\n                    -- setup lock key\n                    redis.call("SET", lockKey, lockInstance, "EX", lockTimeout)\n                    return processingWorkflowApplicationUuid\n                end\n            end\n        end\n    end\nend\n\nreturn nil\n';
